// main.rs
// This is a simple Rust to Ada converter that processes Rust files and converts them to Ada.
// It is a work in progress and may not cover all Rust features or idioms.

// (c) 2025 Zayn Otley
// GPLv3 License or later
// https://github.com/intuitionamiga/rust2ada

use std::fs;
use std::collections::HashMap;
use std::path::{Path, PathBuf};
use std::convert::TryInto;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args: Vec<String> = std::env::args().collect();
    if args.len() < 3 {
        eprintln!("Usage: rust2ada <input.rs> <output.adb>");
        return Ok(());
    }

    let source_path = PathBuf::from(&args[1]);
    let target_path = PathBuf::from(&args[2]);

    // For directory conversion, process recursively
    if source_path.is_dir() {
        convert_directory(&source_path, &target_path)?;
    } else {
        convert_file(&source_path, &target_path)?;
    }

    Ok(())
}

fn convert_directory(source_dir: &Path, target_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    if !target_dir.exists() {
        fs::create_dir_all(target_dir)?;
    }

    for entry in fs::read_dir(source_dir)? {
        let entry = entry?;
        let path = entry.path();

        let relative_path = path.strip_prefix(source_dir)?;
        let target_path = target_dir.join(relative_path);

        if path.is_dir() {
            convert_directory(&path, &target_path)?;
        } else if path.extension().and_then(|ext| ext.to_str()) == Some("rs") {
            let target_ada_path = target_path.with_extension("adb");
            convert_file(&path, &target_ada_path)?;

            // Create spec file (.ads) as well
            let target_spec_path = target_path.with_extension("ads");
            create_spec_file(&path, &target_spec_path)?;
        }
    }

    Ok(())
}

fn convert_file(source_path: &Path, target_path: &Path) -> Result<(), Box<dyn std::error::Error>> {
    println!("Converting {} to {}", source_path.display(), target_path.display());

    let rust_code = fs::read_to_string(source_path)?;
    let ada_code = rust_to_ada(&rust_code, source_path)?;

    // Ensure target directory exists
    if let Some(parent) = target_path.parent() {
        if !parent.exists() {
            fs::create_dir_all(parent)?;
        }
    }

    fs::write(target_path, ada_code)?;
    Ok(())
}

fn create_spec_file(source_path: &Path, target_path: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let rust_code = fs::read_to_string(source_path)?;
    let ada_spec = rust_to_ada_spec(&rust_code, source_path)?;

    // Ensure target directory exists
    if let Some(parent) = target_path.parent() {
        if !parent.exists() {
            fs::create_dir_all(parent)?;
        }
    }

    fs::write(target_path, ada_spec)?;
    Ok(())
}

fn rust_to_ada(rust_code: &str, source_path: &Path) -> Result<String, Box<dyn std::error::Error>> {
    let package_name = get_package_name(source_path);

    let mut ada_code = String::new();

    // Ada package preamble
    ada_code.push_str("-- Generated by PrEP (Programmatic rust Extraction and Protection)\n");
    ada_code.push_str(&format!("-- Source: {}\n\n", source_path.display()));
    ada_code.push_str("with Ada.Text_IO; use Ada.Text_IO;\n");
    ada_code.push_str("with Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n");
    ada_code.push_str("with Ada.Directories; use Ada.Directories;\n");
    ada_code.push_str("with Ada.Containers.Vectors;\n");
    ada_code.push_str("with Ada.Containers.Hashed_Maps;\n");
    ada_code.push_str("with Ada.Exceptions; use Ada.Exceptions;\n\n");

    // Package body
    ada_code.push_str(&format!("package body {} is\n\n", package_name));

    // Type definitions for common Rust types
    ada_code.push_str("   -- Type definitions for common Rust equivalents\n");
    ada_code.push_str("   subtype String_Path is Unbounded_String;\n");
    ada_code.push_str("   type File_Error is new Exception_Id;\n\n");

    // Parse and extract all function declarations
    let functions = extract_functions(rust_code);

    // Convert each function to Ada
    for (name, body) in &functions {
        let ada_function = convert_function(body, name);
        ada_code.push_str(&ada_function);
        ada_code.push_str("\n\n");
    }

    // Add main function
    if functions.contains_key("main") {
        ada_code.push_str("   procedure Run is\n");
        ada_code.push_str("   begin\n");
        ada_code.push_str("      Main;\n");
        ada_code.push_str("   exception\n");
        ada_code.push_str("      when E : others =>\n");
        ada_code.push_str("         Put_Line(\"Error: \" & Exception_Message(E));\n");
        ada_code.push_str("   end Run;\n\n");
    }

    ada_code.push_str(&format!("end {};\n", package_name));

    Ok(ada_code)
}

fn rust_to_ada_spec(rust_code: &str, source_path: &Path) -> Result<String, Box<dyn std::error::Error>> {
    let package_name = get_package_name(source_path);

    let mut ada_spec = String::new();

    // Ada spec preamble
    ada_spec.push_str("-- Generated by PrEP (Programmatic rust Extraction and Protection)\n");
    ada_spec.push_str(&format!("-- Source: {}\n\n", source_path.display()));
    ada_spec.push_str("with Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n");
    ada_spec.push_str("with Ada.Containers.Vectors;\n");
    ada_spec.push_str("with Ada.Containers.Hashed_Maps;\n\n");

    // Package specification
    ada_spec.push_str(&format!("package {} is\n\n", package_name));

    // Type definitions for common Rust types
    ada_spec.push_str("   -- Type definitions for common Rust equivalents\n");
    ada_spec.push_str("   subtype String_Path is Unbounded_String;\n\n");

    // Extract and convert function signatures
    let functions = extract_functions(rust_code);

    for (name, body) in &functions {
        let ada_signature = convert_function_signature(body, name);
        ada_spec.push_str(&format!("   {};\n\n", ada_signature));
    }

    // Add run procedure for main
    if functions.contains_key("main") {
        ada_spec.push_str("   procedure Run;\n");
    }

    ada_spec.push_str(&format!("end {};\n", package_name));

    Ok(ada_spec)
}

fn get_package_name(path: &Path) -> String {
    path.file_stem()
        .and_then(|s| s.to_str())
        .map(|s| {
            // Convert snake_case to Ada_Case
            let mut result = String::new();
            let mut capitalize_next = true;

            for c in s.chars() {
                if c == '_' {
                    result.push('_');
                    capitalize_next = true;
                } else if capitalize_next {
                    result.push(c.to_ascii_uppercase());
                    capitalize_next = false;
                } else {
                    result.push(c);
                }
            }

            result
        })
        .unwrap_or_else(|| "Rust_Conversion".to_string())
}

fn extract_functions(code: &str) -> HashMap<String, String> {
    let mut functions = HashMap::new();
    let mut current_fn = String::new();
    let mut in_fn = false;
    let mut fn_name = String::new();
    let mut brace_count = 0;

    for line in code.lines() {
        let trimmed = line.trim();

        if trimmed.starts_with("fn ") {
            in_fn = true;
            brace_count = 0;
            fn_name = trimmed
                .strip_prefix("fn ")
                .unwrap_or("")
                .split('(')
                .next()
                .unwrap_or("")
                .trim()
                .to_string();
            current_fn.clear();
        }

        if in_fn {
            current_fn.push_str(line);
            current_fn.push('\n');

            brace_count += line.chars().filter(|&c| c == '{').count();
            brace_count -= line.chars().filter(|&c| c == '}').count();

            if brace_count == 0 && !current_fn.is_empty() {
                functions.insert(fn_name.clone(), current_fn.clone());
                in_fn = false;
            }
        }
    }

    functions
}

fn convert_function_signature(rust_fn: &str, name: &str) -> String {
    let signature_line = rust_fn.lines().next().unwrap_or("").trim();

    // Extract parameters
    let params = if let Some(params_part) = signature_line.split('(').nth(1) {
        let params_end = params_part.find(')').unwrap_or(params_part.len());
        let params_str = &params_part[..params_end];

        if params_str.is_empty() {
            String::new()
        } else {
            // Convert parameters to Ada
            params_str
                .split(',')
                .map(|param| {
                    let parts: Vec<&str> = param.trim().split(':').collect();
                    if parts.len() >= 2 {
                        let param_name = parts[0].trim();
                        let param_type = convert_type(parts[1].trim());
                        format!("{} : {}", param_name, param_type)
                    } else {
                        "Invalid_Param : Ada.Strings.Unbounded.Unbounded_String".to_string()
                    }
                })
                .collect::<Vec<String>>()
                .join("; ")
        }
    } else {
        String::new()
    };

    // Extract return type
    let return_type = if signature_line.contains("->") {
        let ret_type = signature_line
            .split("->")
            .nth(1)
            .unwrap_or("")
            .split('{')
            .next()
            .unwrap_or("")
            .trim();

        format!(" return {}", convert_result_type(ret_type))
    } else {
        String::new()
    };

    // Determine if function or procedure
    let subprogram_type = if return_type.is_empty() {
        "procedure"
    } else {
        "function"
    };

    format!("{} {}({}){}", subprogram_type, name, params, return_type)
}

fn convert_function(rust_fn: &str, name: &str) -> String {
    let signature = convert_function_signature(rust_fn, name);
    let mut ada_fn = format!("   {} is\n", signature);

    // Add local variables section
    ada_fn.push_str("      -- Local variables will be declared here\n");
    ada_fn.push_str("   begin\n");

    // Extract and convert function body
    let lines: Vec<&str> = rust_fn.lines().collect();
    let body_start = lines.iter().position(|&line| line.contains('{'))
        .map(|pos| pos + 1)
        .unwrap_or(1);

    let body_lines = &lines[body_start..];
    let mut indent_level: i32 = 6; // Initial indentation (3 spaces per level)

    for line in body_lines {
        let trimmed = line.trim();

        // Skip closing braces and empty lines
        if trimmed == "}" || trimmed.is_empty() {
            continue;
        }

        // Adjust indentation level based on braces
        if trimmed.starts_with('}') {
            indent_level = indent_level.saturating_sub(3);
        }

        // Convert the line to Ada
        let ada_line = convert_statement(trimmed);

        // Add the converted line with proper indentation
        let indent = " ".repeat(indent_level.try_into().unwrap());
        ada_fn.push_str(&format!("{}{}\n", indent, ada_line));

        // Increase indentation after blocks that open
        if trimmed.ends_with('{') {
            indent_level += 3;
        }
    }

    // Add error handling if the function returns a Result
    if rust_fn.contains("Result<") {
        ada_fn.push_str("   exception\n");
        ada_fn.push_str("      when E : others =>\n");
        ada_fn.push_str("         return (Success => False, Error => To_Unbounded_String(Exception_Message(E)));\n");
    }

    ada_fn.push_str("   end;\n");

    ada_fn
}

fn convert_type(rust_type: &str) -> String {
    let rust_type = rust_type.trim();

    match rust_type {
        "i8" | "i16" | "i32" => "Integer".to_string(),
        "u8" | "u16" | "u32" => "Natural".to_string(),
        "i64" | "i128" => "Long_Integer".to_string(),
        "u64" | "u128" => "Long_Natural".to_string(),
        "f32" => "Float".to_string(),
        "f64" => "Long_Float".to_string(),
        "bool" => "Boolean".to_string(),
        "()" => "Void".to_string(),
        t if t.starts_with("&str") || t.starts_with("String") => "Unbounded_String".to_string(),
        t if t.starts_with("Vec<") => {
            let inner_type = extract_generic_type(t, "Vec");
            format!("Ada.Containers.Vectors.Vector(Natural, {})", convert_type(inner_type))
        },
        t if t.starts_with("HashMap<") => {
            let types = extract_map_types(t);
            if types.len() == 2 {
                format!("Ada.Containers.Hashed_Maps.Map({}, {})",
                    convert_type(&types[0]),
                    convert_type(&types[1]))
            } else {
                "Ada.Containers.Hashed_Maps.Map".to_string()
            }
        },
        t if t.starts_with("Option<") => {
            let inner_type = extract_generic_type(t, "Option");
            format!("access {}", convert_type(inner_type))
        },
        t if t.starts_with("Result<") => {
            convert_result_type(t)
        },
        t if t.starts_with("Box<") || t.contains("Error") => "Ada.Exceptions.Exception_Id".to_string(),
        t if t.contains("Path") => "String_Path".to_string(),
        _ => rust_type.to_string(),
    }
}

fn convert_result_type(rust_type: &str) -> String {
    let rust_type = rust_type.trim();

    if rust_type.starts_with("Result<") {
        let inner_type = extract_generic_type(rust_type, "Result");
        let parts: Vec<&str> = inner_type.split(',').collect();

        if parts.len() >= 2 {
            let ok_type = convert_type(parts[0].trim());

            // Create record type for Result
            format!("record (Success : Boolean := True) is\n      case Success is\n         when True =>\n            Value : {};\n         when False =>\n            Error : Unbounded_String;\n      end case;\n   end record", ok_type)
        } else {
            // Simple Result without error type
            format!("record (Success : Boolean := True) is\n      case Success is\n         when True =>\n            Value : {};\n         when False =>\n            Error : Unbounded_String;\n      end case;\n   end record", convert_type(inner_type))
        }
    } else {
        convert_type(rust_type)
    }
}

fn extract_generic_type<'a>(type_str: &'a str, container: &'a str) -> &'a str {
    let prefix = format!("{}< ", container);
    let start = type_str.find(&prefix).map(|pos| pos + prefix.len())
        .or_else(|| type_str.find(&format!("{}<", container)).map(|pos| pos + container.len() + 1))
        .unwrap_or(0);

    let end = type_str[start..].rfind('>').map(|pos| start + pos).unwrap_or(type_str.len());

    &type_str[start..end]
}

fn extract_map_types(map_type: &str) -> Vec<String> {
    let inner = extract_generic_type(map_type, "HashMap");
    inner.split(',')
        .map(|s| s.trim().to_string())
        .collect()
}

fn convert_statement(rust_stmt: &str) -> String {
    let stmt = rust_stmt.trim_end_matches(';');

    if stmt.starts_with("return ") {
        // Handle Result return
        if stmt.contains("Ok(") {
            "return (Success => True, Value => Result_Value);".to_string()
        } else if stmt.contains("Err(") {
            "return (Success => False, Error => To_Unbounded_String(\"Error\"));".to_string()
        } else {
            format!("return {};", stmt.strip_prefix("return ").unwrap_or("").trim())
        }
    } else if stmt.starts_with("let ") {
        convert_let_statement(stmt)
    } else if stmt.starts_with("if ") {
        convert_if_statement(stmt)
    } else if stmt.starts_with("for ") {
        convert_for_statement(stmt)
    } else if stmt.starts_with("while ") {
        convert_while_statement(stmt)
    } else if stmt.contains(".push(") {
        convert_push_statement(stmt)
    } else if stmt.contains(".collect") {
        convert_collect_statement(stmt)
    } else if stmt.contains("fs::") {
        convert_fs_statement(stmt)
    } else if stmt.contains("println!") || stmt.contains("eprintln!") {
        convert_print_statement(stmt)
    } else if stmt.contains("map(") || stmt.contains("filter(") {
        "-- Iterator operation converted to Ada loop construct;".to_string()
    } else {
        // Default conversion - add a semicolon if not present
        if !stmt.ends_with(';') {
            format!("{};", stmt)
        } else {
            stmt.to_string()
        }
    }
}

fn convert_let_statement(stmt: &str) -> String {
    let var_part = stmt.strip_prefix("let ").unwrap_or("").trim();

    if let Some((name_part, value_part)) = var_part.split_once('=') {
        let name = name_part.trim().trim_end_matches(':');
        let value = value_part.trim();

        // Handle mutable variables
        let name = name.trim_start_matches("mut ");

        // Try to infer type from value
        if value.starts_with("Vec::new()") {
            format!("{} : Ada.Containers.Vectors.Vector;", name)
        } else if value.starts_with("HashMap::new()") {
            format!("{} : Ada.Containers.Hashed_Maps.Map;", name)
        } else if value.starts_with("String::new()") || value.starts_with("\"") {
            format!("{} : Unbounded_String := To_Unbounded_String({});", name, value)
        } else if value == "true" || value == "false" {
            format!("{} : Boolean := {};", name, value.to_uppercase())
        } else if value.chars().all(|c| c.is_digit(10) || c == '-') {
            format!("{} : Integer := {};", name, value)
        } else {
            format!("{} := {};", name, value)
        }
    } else {
        format!("-- Unhandled let statement: {}", stmt)
    }
}

fn convert_if_statement(stmt: &str) -> String {
    let condition = stmt.strip_prefix("if ").unwrap_or("").trim()
        .trim_end_matches('{')
        .replace("==", "=")
        .replace("!=", "/=")
        .replace("&&", "and")
        .replace("||", "or");

    format!("if {} then", condition)
}

fn convert_for_statement(stmt: &str) -> String {
    let for_part = stmt.strip_prefix("for ").unwrap_or("").trim();

    if let Some((var_part, iter_part)) = for_part.split_once("in") {
        let var_name = var_part.trim();
        let iter_expr = iter_part.trim().trim_end_matches('{');

        if iter_expr.contains("..") {
            // Range-based for loop
            let range_parts: Vec<&str> = iter_expr.split("..").collect();
            if range_parts.len() == 2 {
                let start = range_parts[0].trim();
                let end = range_parts[1].trim();
                format!("for {} in {} .. {} loop", var_name, start, end)
            } else {
                format!("-- Converted for loop: for {} in range loop", var_name)
            }
        } else {
            // Iterator-based for loop
            format!("for {} of {} loop", var_name, iter_expr)
        }
    } else {
        format!("-- Converted for loop: {}", stmt)
    }
}

fn convert_while_statement(stmt: &str) -> String {
    let condition = stmt.strip_prefix("while ").unwrap_or("").trim()
        .trim_end_matches('{')
        .replace("==", "=")
        .replace("!=", "/=")
        .replace("&&", "and")
        .replace("||", "or");

    format!("while {} loop", condition)
}

fn convert_push_statement(stmt: &str) -> String {
    if let Some((collection, value)) = stmt.split_once(".push(") {
        let collection = collection.trim();
        let value = value.trim().trim_end_matches(");");
        format!("Ada.Containers.Vectors.Append({}, {});", collection, value)
    } else {
        format!("-- Converted push: {}", stmt)
    }
}

fn convert_collect_statement(stmt: &str) -> String {
    format!("-- Converted collect operation: {}", stmt)
}

fn convert_fs_statement(stmt: &str) -> String {
    if stmt.contains("fs::read_to_string") {
        "Ada.Text_IO.Open(File, Ada.Text_IO.In_File, Filename);".to_string()
    } else if stmt.contains("fs::write") {
        "Ada.Text_IO.Create(File, Ada.Text_IO.Out_File, Filename);".to_string()
    } else if stmt.contains("fs::create_dir") {
        "Ada.Directories.Create_Directory(Directory_Name);".to_string()
    } else if stmt.contains("fs::read_dir") {
        "Dir_Search := Ada.Directories.Start_Search(Directory_Name, \"\");".to_string()
    } else {
        format!("-- Converted file operation: {}", stmt)
    }
}

fn convert_print_statement(stmt: &str) -> String {
    if let Some(content) = stmt.find('(').map(|pos| &stmt[pos+1..]) {
        let end_pos = content.rfind(')').unwrap_or(content.len());
        let print_content = &content[..end_pos];

        format!("Ada.Text_IO.Put_Line({});", print_content)
    } else {
        "Ada.Text_IO.Put_Line(\"Output\");".to_string()
    }
}
